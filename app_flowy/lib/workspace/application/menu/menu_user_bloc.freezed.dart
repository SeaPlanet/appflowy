// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'menu_user_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$MenuUserEventTearOff {
  const _$MenuUserEventTearOff();

  _Initial initial() {
    return const _Initial();
  }

  _FetchWorkspaces fetchWorkspaces() {
    return const _FetchWorkspaces();
  }
}

/// @nodoc
const $MenuUserEvent = _$MenuUserEventTearOff();

/// @nodoc
mixin _$MenuUserEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchWorkspaces,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchWorkspaces,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_FetchWorkspaces value) fetchWorkspaces,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_FetchWorkspaces value)? fetchWorkspaces,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MenuUserEventCopyWith<$Res> {
  factory $MenuUserEventCopyWith(
          MenuUserEvent value, $Res Function(MenuUserEvent) then) =
      _$MenuUserEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$MenuUserEventCopyWithImpl<$Res>
    implements $MenuUserEventCopyWith<$Res> {
  _$MenuUserEventCopyWithImpl(this._value, this._then);

  final MenuUserEvent _value;
  // ignore: unused_field
  final $Res Function(MenuUserEvent) _then;
}

/// @nodoc
abstract class _$InitialCopyWith<$Res> {
  factory _$InitialCopyWith(_Initial value, $Res Function(_Initial) then) =
      __$InitialCopyWithImpl<$Res>;
}

/// @nodoc
class __$InitialCopyWithImpl<$Res> extends _$MenuUserEventCopyWithImpl<$Res>
    implements _$InitialCopyWith<$Res> {
  __$InitialCopyWithImpl(_Initial _value, $Res Function(_Initial) _then)
      : super(_value, (v) => _then(v as _Initial));

  @override
  _Initial get _value => super._value as _Initial;
}

/// @nodoc

class _$_Initial implements _Initial {
  const _$_Initial();

  @override
  String toString() {
    return 'MenuUserEvent.initial()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Initial);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchWorkspaces,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchWorkspaces,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_FetchWorkspaces value) fetchWorkspaces,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_FetchWorkspaces value)? fetchWorkspaces,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements MenuUserEvent {
  const factory _Initial() = _$_Initial;
}

/// @nodoc
abstract class _$FetchWorkspacesCopyWith<$Res> {
  factory _$FetchWorkspacesCopyWith(
          _FetchWorkspaces value, $Res Function(_FetchWorkspaces) then) =
      __$FetchWorkspacesCopyWithImpl<$Res>;
}

/// @nodoc
class __$FetchWorkspacesCopyWithImpl<$Res>
    extends _$MenuUserEventCopyWithImpl<$Res>
    implements _$FetchWorkspacesCopyWith<$Res> {
  __$FetchWorkspacesCopyWithImpl(
      _FetchWorkspaces _value, $Res Function(_FetchWorkspaces) _then)
      : super(_value, (v) => _then(v as _FetchWorkspaces));

  @override
  _FetchWorkspaces get _value => super._value as _FetchWorkspaces;
}

/// @nodoc

class _$_FetchWorkspaces implements _FetchWorkspaces {
  const _$_FetchWorkspaces();

  @override
  String toString() {
    return 'MenuUserEvent.fetchWorkspaces()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _FetchWorkspaces);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() fetchWorkspaces,
  }) {
    return fetchWorkspaces();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? fetchWorkspaces,
    required TResult orElse(),
  }) {
    if (fetchWorkspaces != null) {
      return fetchWorkspaces();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_FetchWorkspaces value) fetchWorkspaces,
  }) {
    return fetchWorkspaces(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_FetchWorkspaces value)? fetchWorkspaces,
    required TResult orElse(),
  }) {
    if (fetchWorkspaces != null) {
      return fetchWorkspaces(this);
    }
    return orElse();
  }
}

abstract class _FetchWorkspaces implements MenuUserEvent {
  const factory _FetchWorkspaces() = _$_FetchWorkspaces;
}

/// @nodoc
class _$MenuUserStateTearOff {
  const _$MenuUserStateTearOff();

  _MenuUserState call(
      {required UserProfile user,
      required Option<List<Workspace>> workspaces,
      required Either<Unit, String> successOrFailure}) {
    return _MenuUserState(
      user: user,
      workspaces: workspaces,
      successOrFailure: successOrFailure,
    );
  }
}

/// @nodoc
const $MenuUserState = _$MenuUserStateTearOff();

/// @nodoc
mixin _$MenuUserState {
  UserProfile get user => throw _privateConstructorUsedError;
  Option<List<Workspace>> get workspaces => throw _privateConstructorUsedError;
  Either<Unit, String> get successOrFailure =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $MenuUserStateCopyWith<MenuUserState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MenuUserStateCopyWith<$Res> {
  factory $MenuUserStateCopyWith(
          MenuUserState value, $Res Function(MenuUserState) then) =
      _$MenuUserStateCopyWithImpl<$Res>;
  $Res call(
      {UserProfile user,
      Option<List<Workspace>> workspaces,
      Either<Unit, String> successOrFailure});
}

/// @nodoc
class _$MenuUserStateCopyWithImpl<$Res>
    implements $MenuUserStateCopyWith<$Res> {
  _$MenuUserStateCopyWithImpl(this._value, this._then);

  final MenuUserState _value;
  // ignore: unused_field
  final $Res Function(MenuUserState) _then;

  @override
  $Res call({
    Object? user = freezed,
    Object? workspaces = freezed,
    Object? successOrFailure = freezed,
  }) {
    return _then(_value.copyWith(
      user: user == freezed
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserProfile,
      workspaces: workspaces == freezed
          ? _value.workspaces
          : workspaces // ignore: cast_nullable_to_non_nullable
              as Option<List<Workspace>>,
      successOrFailure: successOrFailure == freezed
          ? _value.successOrFailure
          : successOrFailure // ignore: cast_nullable_to_non_nullable
              as Either<Unit, String>,
    ));
  }
}

/// @nodoc
abstract class _$MenuUserStateCopyWith<$Res>
    implements $MenuUserStateCopyWith<$Res> {
  factory _$MenuUserStateCopyWith(
          _MenuUserState value, $Res Function(_MenuUserState) then) =
      __$MenuUserStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {UserProfile user,
      Option<List<Workspace>> workspaces,
      Either<Unit, String> successOrFailure});
}

/// @nodoc
class __$MenuUserStateCopyWithImpl<$Res>
    extends _$MenuUserStateCopyWithImpl<$Res>
    implements _$MenuUserStateCopyWith<$Res> {
  __$MenuUserStateCopyWithImpl(
      _MenuUserState _value, $Res Function(_MenuUserState) _then)
      : super(_value, (v) => _then(v as _MenuUserState));

  @override
  _MenuUserState get _value => super._value as _MenuUserState;

  @override
  $Res call({
    Object? user = freezed,
    Object? workspaces = freezed,
    Object? successOrFailure = freezed,
  }) {
    return _then(_MenuUserState(
      user: user == freezed
          ? _value.user
          : user // ignore: cast_nullable_to_non_nullable
              as UserProfile,
      workspaces: workspaces == freezed
          ? _value.workspaces
          : workspaces // ignore: cast_nullable_to_non_nullable
              as Option<List<Workspace>>,
      successOrFailure: successOrFailure == freezed
          ? _value.successOrFailure
          : successOrFailure // ignore: cast_nullable_to_non_nullable
              as Either<Unit, String>,
    ));
  }
}

/// @nodoc

class _$_MenuUserState implements _MenuUserState {
  const _$_MenuUserState(
      {required this.user,
      required this.workspaces,
      required this.successOrFailure});

  @override
  final UserProfile user;
  @override
  final Option<List<Workspace>> workspaces;
  @override
  final Either<Unit, String> successOrFailure;

  @override
  String toString() {
    return 'MenuUserState(user: $user, workspaces: $workspaces, successOrFailure: $successOrFailure)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MenuUserState &&
            (identical(other.user, user) ||
                const DeepCollectionEquality().equals(other.user, user)) &&
            (identical(other.workspaces, workspaces) ||
                const DeepCollectionEquality()
                    .equals(other.workspaces, workspaces)) &&
            (identical(other.successOrFailure, successOrFailure) ||
                const DeepCollectionEquality()
                    .equals(other.successOrFailure, successOrFailure)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(user) ^
      const DeepCollectionEquality().hash(workspaces) ^
      const DeepCollectionEquality().hash(successOrFailure);

  @JsonKey(ignore: true)
  @override
  _$MenuUserStateCopyWith<_MenuUserState> get copyWith =>
      __$MenuUserStateCopyWithImpl<_MenuUserState>(this, _$identity);
}

abstract class _MenuUserState implements MenuUserState {
  const factory _MenuUserState(
      {required UserProfile user,
      required Option<List<Workspace>> workspaces,
      required Either<Unit, String> successOrFailure}) = _$_MenuUserState;

  @override
  UserProfile get user => throw _privateConstructorUsedError;
  @override
  Option<List<Workspace>> get workspaces => throw _privateConstructorUsedError;
  @override
  Either<Unit, String> get successOrFailure =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$MenuUserStateCopyWith<_MenuUserState> get copyWith =>
      throw _privateConstructorUsedError;
}
